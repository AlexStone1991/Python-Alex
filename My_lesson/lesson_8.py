# TODO Урок 8. Методы множеств. Работа со словарями.Однострочники.
import random

"""
Урок 8
15.12.2023

1. Сеты. Хеширование и рандом на практике (орел решка)
2. Методы сетов (анализ коллекции фильмов)
3. Знакомство со словарями
"""

# PRACTICE Орел Решка на сетах
"""
Подкидываем монетку через while и сеты
1. Сделайте переменную счетчик (опционально, это может быть пользовательским вводом - сколько хотите раз подкинуть монетку)
2. Сделайте цикл while пока счетчик меньше 10
3. Внутри цикла сделайте сет с 2 строками, орел, решка
4. Сделайте принт сет.pop и счетчик + 1
"""
# coin_set = {"орел", "решка"}
# print(coin_set.pop())

THROUGHOUT = 10
coin_list = ["орел", "решка"]
# счетчик орла и решки
eagle_count = 0
tails_count = 0

for i in range(THROUGHOUT):
    coin = random.choice(coin_list)
    if coin == "орел":
        eagle_count += 1
    else:
        tails_count += 1
    print(coin)
print(f"Орел {eagle_count} Решка {tails_count}")


"""
Давайте разберем полную картину:

В Python строковые литералы (строки в кавычках) интернируются - это значит, что Python повторно использует уже созданные строки вместо создания новых копий. Когда вы пишете {'орел', 'решка'} много раз в цикле, Python не создает новые строки каждый раз, а использует ссылки на уже существующие.

Представьте это как колоду карт:

У вас есть две карты: Туз ♠️ (орел) и Король ♠️ (решка)
Каждый раунд вы:
Берете КОПИИ этих же самых карт (но это те же самые карты, просто новая колода)
Раскладываете их по тем же правилам (хеширование)
Туз всегда ложится слева, потому что его "вес" (хеш) меньше
Король всегда справа
Берете левую карту (pop берет первый элемент по хешу)
И получаете каждый раз Туза!
"""

# Методы сетов

"""
add(item) - добавляет элемент в множество
clear() - удаляет все элементы из множества
copy() - возвращает копию множества
difference(set) - или оператор - возвращает разницу между множествами
difference_update(set) - или оператор -= удаляет элементы из множества, которые есть во втором множестве
discard(item) - удаляет элемент из множества, если он там есть
intersection(set) - или оператор & возвращает пересечение множеств
intersection_update(set) - или оператор &= обновляет множество, оставляя только элементы, которые есть в обоих множествах
isdisjoint(set) - возвращает True, если множества не имеют общих элементов
issubset(set) - возвращает True, если все элементы множества содержатся во втором множестве
issuperset(set) - возвращает True, если все элементы второго множества содержатся в первом множестве
symmetric_difference(set) - или оператор ^ возвращает симметричную разность множеств (элементы, которые есть только в одном из множеств)
symmetric_difference_update(set) - или оператор ^= обновляет множество, оставляя только элементы, которые есть только в одном из множеств
union(set) - или оператор | возвращает объединение множеств
update(set) - или оператор |= обновляет множество, добавляя элементы из другого множества
"""

new_set = {} # это не сет, это словарь
new_set = set() # это сет

# add -  добавляет элемент в множество
new_set.add("Хлеб")
new_set.add("хлеб")
new_set.add("хлеБ")
new_set.add("коньяк")

print(new_set)

# discard - удаляет элемент из множества, если он там есть
new_set.discard("коньяк")
print(new_set)

my_movies = {"Терминатор", "Матрица", "Начало", "Гладиатор", "Бойцовский клуб", "Престиж", "Интерстеллар"}
wife_movies = {"Титаник", "Дневник памяти", "Престиж", "Интерстеллар", "Ла-Ла Ленд", "Гордость и предубеждение"}

print()

# union - возвращает объединение множеств |
print(my_movies | wife_movies)

# isdisjoint - возвращает True, если множества не имеют общих элементов
print(my_movies.isdisjoint(wife_movies))

# issubset - возвращает True, если все элементы множества содержатся во втором множестве

print(my_movies.issubset(wife_movies))

# Словари - dict
# словарь - это упорядоченная коллекция данных, состоящая из пар ключ - значение.

some_dict = {}
some_dict = dict()

some_dict = {
    "key1": "value1",
    "key2": "value2",
    "key3": "value3",
}