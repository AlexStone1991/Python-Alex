# Импортируем модуль для работы с операционной системой (проверка файлов)
# Импортируем модуль для работы с JSON файлами

"""
Класс ToDo - это шаблон для создания задач
Каждая задача будет объектом этого класса
"""
# class ToDo: 
# Конструктор класса - вызывается при создании новой задачи
# def __init__(self, id, title, discription, status=False):
# Уникальный идентификатор задачи (число)
# Название задачи (строка)
# Описание задачи (строка)
# Статус выполнения: False - не выполнено, True - выполнено

# Метод для преобразования объекта задачи в словарь
# Нужен потому что JSON не понимает объекты Python, только простые типы данных
# def to_dict(self):

# Возвращаем ID как число
# Возвращаем название как строку
# Возвращаем описание как строку
# Возвращаем статус как True/False


"""
Функция загрузки задач из файла
Зачем: чтобы при запуске программы восстановить все сохраненные задачи
"""
# def load_tasks():
# Проверяем существует ли файл с задачами
# if os.path.exists("todo_fils.json"):
# Открываем файл для чтения ('r' - read)
# encoding="utf-8" чтобы правильно читать русские буквы
# with open("todo_fils.json", "r", encoding="utf-8") as file:
# Загружаем данные из JSON файла в переменную todo_data
# json.load() преобразует JSON в Python объекты (списки, словари)


# Создаем список объектов ToDo из данных файла
# Это называется "list comprehension" - компактный способ создания списков
# Создаем объект ToDo для каждой задачи в файле
# Передаем название из файла
# Передаем описание из файла
# Передаем статус из файла
# Для каждого элемента в todo_data

# Возвращаем список задач

# Если файла нет, возвращаем пустой список

"""
Функция сохранения задач в файл
Зачем: чтобы не потерять задачи после закрытия программы
"""
# def save_tasks(todos):
# Открываем файл для записи ('w' - write)
# Если файла нет - он создается, если есть - перезаписывается
# with open("todo_fils.json", "w", encoding="utf-8") as file:
# Преобразуем все задачи в словари для сохранения в JSON
# to_dict() вызывается для каждого объекта в списке todos


# Сохраняем данные в файл в формате JSON
# indent=4 делает файл красивым и читаемым (добавляет отступы)
# json.dump(todo_data, file, indent=4)

"""
Функция добавления новой задачи
Зачем: чтобы пользователь мог добавлять новые задачи в список
"""
# def add_task(todos):
# Запрашиваем у пользователя данные для новой задачи
# Получаем название
# Получаем описание

# Генерируем уникальный ID для новой задачи
# Если список задач не пустой
# Находим максимальный ID среди всех задач и добавляем 1
# max_id = max(todo.id for todo in todos) + 1
# Если список пустой
# Начинаем с первого ID

# Создаем новый объект задачи с полученными данными
# new_todo = ToDo(max_id, title, discription)
# Добавляем новую задачу в конец списка todos .apppend
# Сохраняем обновленный список задач в файл

# Сообщаем пользователю об успешном добавлении

"""
Функция показа всех задач
Зачем: чтобы пользователь мог видеть все свои задачи
"""
# def show_tasks(todos):
# Проверяем есть ли задачи для показа
# Если список пустой
# Сообщаем об этом
# Выходим из функции досрочно

# Выводим заголовок

# Перебираем все задачи в списке
# Преобразуем статус из True/False в понятный текст
# status = "Выполнено" if todo.status else "Не выполнено"

# Выводим основную информацию о задаче
# print(f"{todo.id}. {todo.title} - {status}")

# Если у задачи есть описание - выводим его
# Пустая строка для красоты

"""
Функция изменения статуса задачи
Зачем: чтобы пользователь мог отмечать задачи выполненными
"""
# def toggle_task_status(todos):
# Показываем все задачи чтобы пользователь видел какие есть

# Проверяем есть ли задачи вообще

# Если нет - выходим

# Блок try-except для обработки ошибок

# Запрашиваем ID задачи и преобразуем в число

# Ищем задачу с нужным ID
# Если нашли нужную задачу
# Меняем статус на противоположный (True ↔ False)
# todo.status = not todo.status

# Сохраняем изменения в файл

# Сообщаем об успехе

# Выходим из функции после успеха

# Если дошли сюда - задача не найдена

# Если пользователь ввел не число

"""
Функция удаления задачи
Зачем: чтобы пользователь мог удалять ненужные задачи
"""
# def delete_task(todos):
# Показываем задачи для выбора

# Проверяем есть ли задачи


# Обрабатываем возможные ошибки

# Получаем ID задачи для удаления

# Перебираем задачи с их индексами (номерами в списке)
# for i, todo in enumerate(todos):
#if todo.id == task_id:  # Если нашли нужную задачу
# Удаляем задачу из списка по индексу

# Сохраняем обновленный список

# Сообщаем об успехе

# Выходим после удаления

# Если задача не найдена


# Если ввели не число

"""
Главная функция программы
Зачем: точка входа в приложение, управляет всем процессом
"""
# def main():
# Загружаем задачи из файла при запуске

# Бесконечный цикл меню - работает пока пользователь не выйдет
# while True:
# Рисуем разделитель для красоты
# print("\n========================")

# Показываем меню с вариантами действий
# print("\nTODO приложение:")
# print("1. Добавить задачу")
# print("2. Показать все задачи")
# print("3. Изменить статус задачи")
# print("4. Удалить задачу")
# print("5. Выйти")

# Запрашиваем выбор пользователя
# choice = input("Выберите действие:(1-5): ")

# Рисуем разделитель
# print("\n========================")

# Обрабатываем выбор пользователя
# Добавляем задачу
# Показываем задачи
# Меняем статус
# Удаляем задачу
# Прощаемся
#break  # Выходим из цикла - завершаем программу
# Если ввели неверный вариант

"""
Специальная проверка которая запускает программу только если
этот файл запущен напрямую, а не импортирован как модуль
"""
# if __name__ == "__main__":
#    main()   Запускаем главную функцию